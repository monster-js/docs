"use strict";(self.webpackChunk_monster_js_docs=self.webpackChunk_monster_js_docs||[]).push([[123],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5914:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:2},i="Store",s={unversionedId:"available-packages/store",id:"available-packages/store",title:"Store",description:"The Store is a state management system designed specifically for the MonsterJS framework. By using the Store, developers can easily centralize the state of their application and ensure that it is consistent throughout the codebase. This makes it easier to maintain and debug the code, as well as to add new features and functionality in a scalable way.",source:"@site/docs/available-packages/store.md",sourceDirName:"available-packages",slug:"/available-packages/store",permalink:"/docs/available-packages/store",draft:!1,editUrl:"https://github.com/monster-js/documentation/docs/available-packages/store.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Available Packages",permalink:"/docs/category/available-packages"},next:{title:"Router",permalink:"/docs/available-packages/router"}},l={},c=[{value:"Installation",id:"installation",level:2},{value:"Create a Store",id:"create-a-store",level:2},{value:"Initial State",id:"initial-state",level:2},{value:"Using The Store",id:"using-the-store",level:2},{value:"Getter",id:"getter",level:2},{value:"Setter",id:"setter",level:2},{value:"Subscribe to Changes",id:"subscribe-to-changes",level:2},{value:"Actions",id:"actions",level:2},{value:"Create Actions",id:"create-actions",level:3},{value:"Dispatch an Action",id:"dispatch-an-action",level:3},{value:"DevTools",id:"devtools",level:2}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"store"},"Store"),(0,r.kt)("p",null,"The Store is a state management system designed specifically for the MonsterJS framework. By using the Store, developers can easily centralize the state of their application and ensure that it is consistent throughout the codebase. This makes it easier to maintain and debug the code, as well as to add new features and functionality in a scalable way."),(0,r.kt)("p",null,"The store is just an extension of shared state. The store is using the shared state behind the scene. It is just a way to organize the data provided by the shared state functionality."),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)("p",null,"To use the Store in your project, you can install it using the following npm command."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @monster-js/store\n")),(0,r.kt)("h2",{id:"create-a-store"},"Create a Store"),(0,r.kt)("p",null,"In order to create a Store, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"createStore")," function, which is provided by the MonsterJS framework. This function accepts an initial state as a parameter, which sets the starting value for the Store's state."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createStore } from '@monster-js/store';\n\nconst initialState = {\n    counter: 0\n};\n\nexport const store = createStore(initialState);\n")),(0,r.kt)("p",null,"Now we have an object with shared state properties."),(0,r.kt)("h2",{id:"initial-state"},"Initial State"),(0,r.kt)("p",null,"It is good practice to separate the initial state and create an interface that describes it. This interface will be useful in other parts of our store."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// initial-state.ts\nexport interface InitialState {\n    counter: number;\n}\n\nexport const initialState: InitialState = {\n    counter: 0;\n};\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// store.ts\nimport { createStore } from '@monster-js/store';\nimport { initialState, InitialState } from './initial-state';\n\nexport const store = createStore<InitialState>(initialState);\n")),(0,r.kt)("h2",{id:"using-the-store"},"Using The Store"),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { store } from './store';\n\nexport function Counter() {\n\n    const [counter, setCounter] = store(this, 'counter');\n\n    return <div>\n        <button on:click={() => setCounter(counter() + 1)}>Increment</button>\n        <h1>Count: {counter()}</h1>\n    </div>\n}\n")),(0,r.kt)("p",null,"Similar to shared state, we can also access a getter function (",(0,r.kt)("inlineCode",{parentName:"p"},"counter"),") and a setter function (",(0,r.kt)("inlineCode",{parentName:"p"},"setCounter"),") for this state."),(0,r.kt)("h2",{id:"getter"},"Getter"),(0,r.kt)("p",null,"To retrieve a value from the store, we can use the getter function of the state."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { store } from './store';\n\nexport function App() {\n\n    const [counter, setCounter] = store(this, 'counter');\n\n    return <h1>Count: {counter()}</h1>\n}\n")),(0,r.kt)("p",null,"In the example above, the ",(0,r.kt)("inlineCode",{parentName:"p"},"counter")," is the getter function."),(0,r.kt)("h2",{id:"setter"},"Setter"),(0,r.kt)("p",null,"We can use the setter function to update the value of the state. When we update the value of the state in the store, the changes will be reflected in the components that use that state."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { store } from './store';\n\nexport function App() {\n\n    const [counter, setCounter] = store(this, 'counter');\n\n    const clickMe = () => {\n        setCounter(counter() + 1);\n    }\n\n    return <button on:click={clickMe}>Increment</button>\n}\n")),(0,r.kt)("h2",{id:"subscribe-to-changes"},"Subscribe to Changes"),(0,r.kt)("p",null,"The store also provides a way to subscribe to changes for each item of the state."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { store } from './store';\n\nexport function App() {\n\n    store(this, 'counter', (value) => {\n        console.log(`Counter value changed: ${value}`);\n        return value;\n    });\n\n    return <h1>App</h1>\n}\n")),(0,r.kt)("p",null,"The callback function should return a value that will be used as the value returned by the getter function. This approach is useful if we need to perform some data manipulation before setting the local state of the component with the value."),(0,r.kt)("h2",{id:"actions"},"Actions"),(0,r.kt)("p",null,"One of the many advantages of using a store instead of shared state is that we can use actions to update the state. Actions can make your code much cleaner, easier to manage, and more understandable."),(0,r.kt)("h3",{id:"create-actions"},"Create Actions"),(0,r.kt)("p",null,"To create an action, we need to create an action creator first."),(0,r.kt)("p",null,"Using our example above, we need to create an action creator for the ",(0,r.kt)("inlineCode",{parentName:"p"},"counter")," state."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// counter.action.ts\nimport { actionCreator } from '@monster-js/store';\nimport { InitialState } from './initial-state';\nimport { store } from './store';\n\nconst counterActionCreator = actionCreator<InitialState>(store, 'counter');\n")),(0,r.kt)("p",null,"After creating an action creator function, we can then use it to create an actual action function. This action can be dispatched to the store, triggering its registered reducers to update the state accordingly."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// counter.action.ts\nimport { actionCreator } from '@monster-js/store';\nimport { InitialState } from './initial-state';\nimport { store } from './store';\n\nconst counterActionCreator = actionCreator<InitialState>(store, 'counter');\n\nexport const incrementCounter = counterActionCreator<number, number>((counterState, payload) => {\n    return counterState + payload;\n}, 'Increment counter');\n")),(0,r.kt)("p",null,"The created action creator function(",(0,r.kt)("inlineCode",{parentName:"p"},"counterActionCreator"),") takes two arguments: the first is the reducer function, and the second is the action description. The reducer function also takes two parameters: the current state, and optionally, the action payload. The return value of the reducer function becomes the new state of the store(in the example above, the counter state of the store)."),(0,r.kt)("p",null,"The created action creator function(",(0,r.kt)("inlineCode",{parentName:"p"},"counterActionCreator"),") has two generic types. First is the type of the state and second is the type of the payload."),(0,r.kt)("h3",{id:"dispatch-an-action"},"Dispatch an Action"),(0,r.kt)("p",null,"To dispatch an action, we just need to call the action inside our component or service."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { store } from './store';\nimport { incrementCounter } from './counter.actions';\n\nexport function App() {\n\n    const [counter] = store(this, 'counter');\n\n    const clickMe = () => {\n        incrementCounter(1);\n    }\n\n    return <div>\n        <h1>Count: {counter()}</h1>\n        <button on:click={clickMe}>Increment</button>\n    </div>\n}\n")),(0,r.kt)("h2",{id:"devtools"},"DevTools"),(0,r.kt)("p",null,"We can also use the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-devtools"},"Redux DevTools")," to inspect the shared state of our application in real-time. This DevTool provides various features, including time travel debugging, which allows us to replay and inspect the state of our application at any point in time. This is especially useful when debugging complex state management scenarios."),(0,r.kt)("p",null,"The Redux DevTools are enabled by default in development mode, allowing us to debug and inspect the state of our application during development. However, when building the application for production, the DevTools will be automatically removed to ensure better performance and security."))}d.isMDXComponent=!0}}]);