"use strict";(self.webpackChunk_monster_js_docs=self.webpackChunk_monster_js_docs||[]).push([[949],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2739:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:7},i="Observed Attributes",s={unversionedId:"main-concept/observed-attributes",id:"main-concept/observed-attributes",title:"Observed Attributes",description:"Observed attributes are values passed down from a parent component to a child component as an element attribute, and their changes are observed by the child component. This feature uses the observed attributes implementation of web components. Similar to web components, it does not accept objects and arrays, and only accepts string values. However, the MonsterJS implementation is more advanced, as it can convert the value into a number or boolean.",source:"@site/docs/main-concept/observed-attributes.md",sourceDirName:"main-concept",slug:"/main-concept/observed-attributes",permalink:"/docs/docs/main-concept/observed-attributes",draft:!1,editUrl:"https://github.com/monster-js/documentation/docs/main-concept/observed-attributes.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Event Handling",permalink:"/docs/docs/main-concept/event-handling"},next:{title:"Props",permalink:"/docs/docs/main-concept/props"}},l={},u=[{value:"Attr Directive",id:"attr-directive",level:2},{value:"Define Observed Attributes",id:"define-observed-attributes",level:2},{value:"String Attribute",id:"string-attribute",level:2},{value:"Child component",id:"child-component",level:4},{value:"Parent component",id:"parent-component",level:4},{value:"Boolean attribute",id:"boolean-attribute",level:2},{value:"Child component",id:"child-component-1",level:4},{value:"Parent component",id:"parent-component-1",level:4},{value:"Number Attribute",id:"number-attribute",level:2},{value:"Child component",id:"child-component-2",level:4},{value:"Parent component",id:"parent-component-2",level:4},{value:"The attributeChanged Hook",id:"the-attributechanged-hook",level:2}],c={toc:u},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"observed-attributes"},"Observed Attributes"),(0,r.kt)("p",null,"Observed attributes are values passed down from a parent component to a child component as an element attribute, and their changes are observed by the child component. This feature uses the observed attributes implementation of web components. Similar to web components, it does not accept objects and arrays, and only accepts string values. However, the MonsterJS implementation is more advanced, as it can convert the value into a number or boolean."),(0,r.kt)("h2",{id:"attr-directive"},"Attr Directive"),(0,r.kt)("p",null,"Observed attributes are directives that are namespaced with ",(0,r.kt)("inlineCode",{parentName:"p"},"attr"),", followed by the attribute name. The syntax of this directive is written as ",(0,r.kt)("inlineCode",{parentName:"p"},"attr:<name>=<data>"),"."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},'<Child attr:message="Hello World!" />\n')),(0,r.kt)("h2",{id:"define-observed-attributes"},"Define Observed Attributes"),(0,r.kt)("p",null,"To define the list of attributes that should be observed by the component, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"observedAttributes")," function to do so."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { observedAttributes } from '@monster-js/core';\n\nexport function App() {\n    return <h1>App</h1>\n}\n\nobservedAttributes(App, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h2",{id:"string-attribute"},"String Attribute"),(0,r.kt)("p",null,"This type of attribute is similar to the observed attributes of a typical web component, which accept a string as a value. In order to retrieve the value and monitor any changes made to the attribute, this type of attribute uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"attribute")," function. This is a built-in function that allows developers to access the value and observe the changes to an element's attributes."),(0,r.kt)("p",null,"Example."),(0,r.kt)("h4",{id:"child-component"},"Child component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { attribute } from '@monster-js/core';\n\nexport function Child() {\n\n    const name = attribute(this, 'name');\n\n    return <h1>{name()}</h1>\n}\n\nobservedAttributes(Child, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h4",{id:"parent-component"},"Parent component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export function parent() {\n\n    const [name] = useState(this, 'John Doe');\n\n    return <Child attr:name={name()} />\n}\n")),(0,r.kt)("p",null,"In the example above, the child component has an observed attribute named ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),". Every time the ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," state of the parent component is changed, it will also be reflected in the child component's name attribute getter."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"attribute")," function can have a third argument that accepts a callback function, which is called whenever the attribute is changed. This allows developers to perform custom logic whenever the attribute value changes."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { attribute } from '@monster-js/core';\n\nexport function Child() {\n\n    const name = attribute(this, 'name', (newValue: string, oldValue: string) => {\n        console.log(newValue, oldValue);\n    });\n\n    return <h1>{name()}</h1>\n}\n\nobservedAttributes(Child, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h2",{id:"boolean-attribute"},"Boolean attribute"),(0,r.kt)("p",null,"This type of attribute has the same implementation as the string attribute described above, with the only difference being that the value is converted into a boolean value instead of a string. The value will be false if the attribute value is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", ",(0,r.kt)("inlineCode",{parentName:"p"},'""')," (an empty string), ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),". To retrieve the value and monitor changes to the attribute, this type of attribute uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"attrBoolean")," function."),(0,r.kt)("p",null,"Example."),(0,r.kt)("h4",{id:"child-component-1"},"Child component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { attrBoolean } from '@monster-js/core';\n\nexport function Child() {\n\n    const isVerified = attrBoolean(this, 'is-verified-user');\n\n    return <h1>{isVerified() ? 'Yes' : 'No'}</h1>\n}\n\nobservedAttributes(Child, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h4",{id:"parent-component-1"},"Parent component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export function Parent() {\n\n    const [isVerified] = useState(this, true);\n\n    return <Child attr:is-verified-user={isVerified()}></Child>\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"attrBoolean")," function can have a third argument that accepts a callback function, which is called whenever the attribute is changed. This allows developers to perform custom logic whenever the attribute value changes."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { attrBoolean } from '@monster-js/core';\n\nexport function Child() {\n\n    const isVerified = attrBoolean(this, 'is-verified-user', (newValue: boolean, oldValue: boolean) => {\n        console.log(newValue, oldValue);\n    });\n\n    return <h1>{isVerified() ? 'Yes' : 'No'}</h1>\n}\n\nobservedAttributes(Child, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h2",{id:"number-attribute"},"Number Attribute"),(0,r.kt)("p",null,"This type of attribute has the same implementation as the string attribute described above, with the only difference being that the value is converted into a numeric value instead of a string. To retrieve the value and monitor changes to the attribute, this type of attribute uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"attrNumber")," function."),(0,r.kt)("p",null,"Example."),(0,r.kt)("h4",{id:"child-component-2"},"Child component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { attrNumber } from '@monster-js/core';\n\nexport function Child() {\n\n    const age = attrNumber(this, 'age');\n\n    return <h1>{age()}</h1>\n}\n\nobservedAttributes(Child, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h4",{id:"parent-component-2"},"Parent component"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"export function Parent() {\n\n    const [age] = useState(this, 20);\n\n    return <Child attr:age={age()}></Child>\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"attrNumber")," function can have a third argument that accepts a callback function, which is called whenever the attribute is changed. This allows developers to perform custom logic whenever the attribute value changes."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { attrNumber } from '@monster-js/core';\n\nexport function Child() {\n\n    const age = attrNumber(this, 'age', (newValue: number, oldValue: number) => {\n        console.log(newValue, oldValue);\n    });\n\n    return <h1>{age()}</h1>\n}\n\nobservedAttributes(Child, ['name', 'age', 'is-verified-user']);\n")),(0,r.kt)("h2",{id:"the-attributechanged-hook"},"The attributeChanged Hook"),(0,r.kt)("p",null,"This is a hook that runs each time one of the observed attributes is added, removed, or updated. It takes two arguments: the first is the ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," context of the component, and the second is the callback. For more information about this hook, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"../main-concept/lifecyle-hooks"},"lifecycle hooks")," documentation."),(0,r.kt)("p",null,"Example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"import { observedAttributes, attributeChanged } from '@monster-js/core';\n\nexport function Child() {\n\n    attributeChanged(this, (name: string, oldValue: any, newValue: any) => {\n        console.log(name, oldValue, newValue);\n    });\n\n    return <h1>Child component</h1>\n}\n\nobservedAttributes(Child, 'name', 'age', 'is-verified-user');\n")))}d.isMDXComponent=!0}}]);