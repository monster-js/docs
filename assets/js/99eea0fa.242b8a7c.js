"use strict";(self.webpackChunk_monster_js_docs=self.webpackChunk_monster_js_docs||[]).push([[390],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function p(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},l=Object.keys(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(o=0;o<l.length;o++)t=l[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),r=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):p(p({},n),e)),t},m=function(e){var n=r(e.components);return o.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},u=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=r(t),u=a,h=c["".concat(s,".").concat(u)]||c[u]||d[u]||l;return t?o.createElement(h,p(p({ref:n},m),{},{components:t})):o.createElement(h,p({ref:n},m))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,p=new Array(l);p[0]=u;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[c]="string"==typeof e?e:a,p[1]=i;for(var r=2;r<l;r++)p[r]=t[r];return o.createElement.apply(null,p)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3562:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>p,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>r});var o=t(7462),a=(t(7294),t(3905));const l={sidebar_position:1},p="Component",i={unversionedId:"main-concept/component",id:"main-concept/component",title:"Component",description:"Components are the most basic building block of an application. They are composed of templates, logic, and styles, and are used to split the UI into small, reusable pieces of code.",source:"@site/docs/main-concept/component.md",sourceDirName:"main-concept",slug:"/main-concept/component",permalink:"/docs/docs/main-concept/component",draft:!1,editUrl:"https://github.com/monster-js/documentation/docs/main-concept/component.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Main Concept",permalink:"/docs/docs/category/main-concept"},next:{title:"Component States",permalink:"/docs/docs/main-concept/component-states"}},s={},r=[{value:"Logic and Template",id:"logic-and-template",level:2},{value:"Styles",id:"styles",level:2},{value:"Render a Component Into View",id:"render-a-component-into-view",level:2},{value:"Shadow Dom Component",id:"shadow-dom-component",level:2},{value:"Web Component Slot",id:"web-component-slot",level:2},{value:"Parent component",id:"parent-component",level:4},{value:"Child component",id:"child-component",level:4},{value:"Named Slot",id:"named-slot",level:3},{value:"Parent component",id:"parent-component-1",level:4},{value:"Child component",id:"child-component-1",level:4},{value:"Custom Element Component",id:"custom-element-component",level:2},{value:"Define Component",id:"define-component",level:2},{value:"Define Custom Element Component",id:"define-custom-element-component",level:2}],m={toc:r},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"component"},"Component"),(0,a.kt)("p",null,"Components are the most basic building block of an application. They are composed of templates, logic, and styles, and are used to split the UI into small, reusable pieces of code."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"A component file must have the extension ",(0,a.kt)("inlineCode",{parentName:"p"},".tsx")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},".ts")," since it contains JSX code.")),(0,a.kt)("h2",{id:"logic-and-template"},"Logic and Template"),(0,a.kt)("p",null,"A component file combines the logic and template in a single file. It is a function that returns a single JSX element with zero to many child JSX elements. To indicate that the file contains JSX code, the component file must have a ",(0,a.kt)("inlineCode",{parentName:"p"},".tsx")," extension instead of ",(0,a.kt)("inlineCode",{parentName:"p"},".ts"),"."),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"export function Greeting() {\n    return <h1>Hello World!</h1>\n}\n")),(0,a.kt)("h2",{id:"styles"},"Styles"),(0,a.kt)("p",null,"MonsterJS uses ",(0,a.kt)("inlineCode",{parentName:"p"},"Sass")," by default, but we can also use other CSS frameworks depending on our webpack configuration. The component styles will only affect its corresponding component and will have no effect on its parent or child components."),(0,a.kt)("p",null,"Component styles are imported directly to the ",(0,a.kt)("inlineCode",{parentName:"p"},".tsx")," file."),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import styles from './greeting.component.scss';\nimport { component } from '@monster-js/core';\n\nexport function Greeting() {\n    return <h1>Hello World!</h1>\n}\n\ncomponent(Greeting, styles);\n")),(0,a.kt)("p",null,"In the example above, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"component")," function to attach the style to the component. However, the component function is only necessary if styles are applied to the component. If no styles are applied, the component function can be omitted."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"To ensure that component styles work properly, the component's logic and styles should have the same filename with a ",(0,a.kt)("inlineCode",{parentName:"p"},".component.tsx")," extension for the logic and a ",(0,a.kt)("inlineCode",{parentName:"p"},".component.scss")," extension for the styles. Additionally, the styles should be imported directly into the component's .tsx file.")),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"greeting\n    \u251c\u2500\u2500 greeting.component.tsx\n    \u2514\u2500\u2500 greeting.component.scss\n")),(0,a.kt)("h2",{id:"render-a-component-into-view"},"Render a Component Into View"),(0,a.kt)("p",null,"To render a component into view, we need to import the component and create a JSX element using the imported component, as shown in the following example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { App } from './app.component';\n\n<App></App>\n")),(0,a.kt)("h2",{id:"shadow-dom-component"},"Shadow Dom Component"),(0,a.kt)("p",null,"We can also create a Shadow DOM component to encapsulate our component. To do this, we can use a custom ",(0,a.kt)("inlineCode",{parentName:"p"},"shadowComponent")," function. This function takes three arguments. The first argument is the function component itself, the second argument is an optional component style, and the third argument is an optional Shadow DOM mode (open or closed), which defaults to open if not specified."),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import styles from './greeting.component.scss';\nimport { shadowComponent } from '@monster-js/core';\n\nexport function Greeting() {\n    return <h1>Hello World</h1>\n}\n\nshadowComponent(Greeting, styles, 'closed');\n")),(0,a.kt)("h2",{id:"web-component-slot"},"Web Component Slot"),(0,a.kt)("p",null,"Using Shadow DOM, we can pass elements from the parent component to the child component's view by using slots. Slots are placeholder elements in the child component's Shadow DOM that allow content from the parent component to be displayed."),(0,a.kt)("p",null,"Example."),(0,a.kt)("h4",{id:"parent-component"},"Parent component"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { Child } from './child.component';\n\nexport function Parent(props) {\n    return <div>\n        <Child>\n            <h1>I am a slot content</h1>\n            <span>I am a slot content</span>\n        </Child>\n    </div>\n}\n")),(0,a.kt)("p",null,"All elements inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"<Child></Child>")," tag will be displayed in the child component slot."),(0,a.kt)("h4",{id:"child-component"},"Child component"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { shadowComponent } from '@monster-js/core';\n\nexport function Child() {\n    return <div>\n        <slot></slot>\n    </div>\n}\n\nshadowComponent(Child);\n")),(0,a.kt)("h3",{id:"named-slot"},"Named Slot"),(0,a.kt)("p",null,"Named slots allow us to choose where we want to display the elements inside the child component's view. A component can have multiple named slots."),(0,a.kt)("p",null,"Example."),(0,a.kt)("h4",{id:"parent-component-1"},"Parent component"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Child } from \'./child.component\';\n\nexport function Parent() {\n    return <div>\n        <Child>\n            <h1 slot="slot-1">I am a slot content</h1>\n            <span slot="slot-2">I am a slot content</span>\n        </Child>\n    </div>\n}\n')),(0,a.kt)("h4",{id:"child-component-1"},"Child component"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import { shadowComponent } from \'@monster-js/core\';\n\nexport function Child() {\n    return <div>\n        <slot name="slot-1"></slot>\n        <div>\n            <slot name="slot-2"></slot>\n        </div>\n    </div>\n}\n\nshadowComponent(Child);\n')),(0,a.kt)("p",null,"In the example above, the element ",(0,a.kt)("inlineCode",{parentName:"p"},'<h1 slot="slot-1">I am a slot content</h1>')," from parent component will be displayed in ",(0,a.kt)("inlineCode",{parentName:"p"},'<slot name="slot-1"></slot>')," in child component. The same for the ",(0,a.kt)("inlineCode",{parentName:"p"},'<span slot="slot-2">I am a slot content</span>')," will be displayed in ",(0,a.kt)("inlineCode",{parentName:"p"},'<slot name="slot-2"></slot>'),"."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Slots only work when using shadow DOM.")),(0,a.kt)("h2",{id:"custom-element-component"},"Custom Element Component"),(0,a.kt)("p",null,"Custom elements allow us to define a new type of element. To create a custom element, we can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"customElement")," function. This function has three parameters: the first is the function component, the second is the type of custom element constructor, and the third is the type of element it will extend."),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { component, customElement } from '@monster-js/core';\n\nexport function CustomButton {\n    return <span>I am a button!</span>\n}\n\ncustomElement(CustomButton, HTMLButtonElement, 'button');\n")),(0,a.kt)("p",null,"To render the above component within its parent component, use the following code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"<CustomButton />\n")),(0,a.kt)("p",null,"When the above example component is rendered, it generates an HTML element like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"<button>\n    <span>I am a button!</span>\n</button>\n")),(0,a.kt)("p",null,"As long as the custom element is defined we can also use it like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'<button is="app-custom-button"></button>\n')),(0,a.kt)("p",null,"Custom element names are prefixed with ",(0,a.kt)("inlineCode",{parentName:"p"},"app-")," when defined."),(0,a.kt)("h2",{id:"define-component"},"Define Component"),(0,a.kt)("p",null,"In order to use a Component outside of a MonsterJS component, it must first be defined using ",(0,a.kt)("inlineCode",{parentName:"p"},"customElement.define"),". This is because MonsterJS components are web components."),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createComponent } from '@monster-js/core';\nimport { Greeting } from './greeting.component';\n\ncustomElement.define('app-greeting', createComponent(Greeting));\n")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Components used within a MonsterJS component do not need to be separately defined, as they are automatically recognized within the scope of the MonsterJS component.")),(0,a.kt)("h2",{id:"define-custom-element-component"},"Define Custom Element Component"),(0,a.kt)("p",null,"Custom element components created by ",(0,a.kt)("inlineCode",{parentName:"p"},"customElement")," function can also be defined using the customElement.define method."),(0,a.kt)("p",null,"Example."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"import { createComponent } from '@monster-js/core';\nimport { CustomButton } from './custom-button.component';\n\ncustomElement.define('app-custom-button', createComponent(CustomButton), {\n    extends: 'button'\n});\n")))}d.isMDXComponent=!0}}]);